<polymer-element name="ceci-element-base">
  <template>
    <content></content>
  </template>


  <!-- localization is .ejs generated from views/localization in app.js -->
  <script src="/components/localization.js"></script>

  <!-- base functions and globals -->
  <script>
    var DEFAULT_CHANNEL = 'blue';

    // Mouse/touch events that need to be routed properly
    var customListenerMap = {
      'on-ceci-pressdown': { eventName: 'ceci-pressdown', mobile: 'touchstart', desktop: 'mousedown' },
      'on-ceci-pressup': { eventName: 'ceci-pressup', mobile: 'touchend', desktop: 'mouseup' }
    };

    // Create a query selector based on the map above, like '[on-ceci-pressdown],[on-ceci-pressup]'.
    var customListenerQuerySelector = Object.keys(customListenerMap).map(function (m) {
      return '[' + m + ']';
    }).join(',');

    function processDefinition (element) {
      var definitionJSON = window.CeciDefinitions[element.localName];

      if (definitionJSON) {
        // Defaults for safety and efficiency :) !
        definitionJSON.tags = definitionJSON.tags || [];
        definitionJSON.thumbnail = definitionJSON.thumbnail || '';
        definitionJSON.listeners = definitionJSON.listeners || {};
        definitionJSON.broadcasts = definitionJSON.broadcasts || {};
        definitionJSON.attributes = definitionJSON.attributes || {};
      }
      else {
        throw new Error("Couldn't find Ceci definition for " + element.localName + ".");
      }

      return definitionJSON;
    }

    function processAttributes (ceciDefinition, attributesDefinitionObject) {
      var result;

      if (!attributesDefinitionObject) return;

      result = {
        listeners: {},
        attributeListeners: {}
      };

      Object.keys(attributesDefinitionObject).forEach(function (attributeName) {
        var attributeDefinition = attributesDefinitionObject[attributeName];

        if (attributeDefinition.listener) {
          var listenerName;

          if (typeof attributeDefinition.listener === 'string') {
            listenerName = attributeDefinition.listener;
          }
          else {
            listenerName = 'set_' + attributeName;
            result.attributeListeners[attributeName] = listenerName;
          }

          result.listeners[listenerName] = {
            description: '(Setter) ' + attributeDefinition.description,
            label: attributeDefinition.label,
            'default': attributeDefinition.defaultListener,
            attribute: attributeName
          };
        }

        if (attributeDefinition.editable) {
          ceciDefinition[attributeName] = {
            description: attributeDefinition.description,
            label: attributeDefinition.label,
            type: attributeDefinition.editable
          };
        }
      });

      return result;
    }

    function processListeners (ceciDefinition, listenersDefinitionObject) {
      var defaultListeners = [];

      if (!listenersDefinitionObject) return defaultListeners;

      Object.keys(listenersDefinitionObject).forEach(function (listenerName) {
        var listenerDefinition = listenersDefinitionObject[listenerName];
        var channel = DEFAULT_CHANNEL;
        ceciDefinition[listenerName] = listenerDefinition;
        if (!!listenerDefinition['default']) {
          if (listenerDefinition['default'] !== true) {
            channel = listenerDefinition['default'];
          }
          defaultListeners.push({name: listenerName, channel: "a" });
        }
      });

      return defaultListeners;
    }

    function processBroadcasts (ceciDefinition, broadcastsDefinitionObject) {
      var defaultBroadcasts = [];

      if (!broadcastsDefinitionObject) return defaultBroadcasts;

      Object.keys(broadcastsDefinitionObject).forEach(function (broadcastName) {
        var broadcastDefinition = broadcastsDefinitionObject[broadcastName];
        var channel = DEFAULT_CHANNEL;
        ceciDefinition[broadcastName] = broadcastDefinition;
        if (!!broadcastDefinition['default']) {
          if (broadcastDefinition['default'] !== true) {
            channel = broadcastDefinition['default'];
          }
          defaultBroadcasts.push({name: broadcastName, channel: "a" });
        }
      });

      return defaultBroadcasts;
    }
  </script>



  <!-- Building the actual polymer element -->
  <script>
    Polymer('ceci-element-base', {
      elementReady: false,
      eventListeners : [],
      sounds : {},
      playSound : function(sound,volume){
        if(this.sounds[sound] && this.ctx){
          if(isNaN(parseFloat(volume))) {
            volume = 1;
          } else {
            volume = parseFloat(volume);
          }
          if(volume > 1) { volume = 1; }
          if(volume < 0) { volume = 0; }
          var gain = this.ctx.createGain();
          gain.gain.value = volume;
          gain.connect(this.ctx.destination);
          var src = this.ctx.createBufferSource();
          src.buffer = this.sounds[sound];
          src.loop = false;
          src.connect(gain);
          src.start(0);
        }
      },
      loadSound : function(soundName,soundPath){
        if(this.ctx){
          var that = this;
          var xhr = new XMLHttpRequest();
          xhr.open("GET", this.resolvePath(soundPath), true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function () {
            if (xhr.response.byteLength) {
              that.ctx.decodeAudioData(xhr.response, function(data) {
                that.sounds[soundName] = data;
              },
              function (e) {
                console.error('Error decoding the audio buffer.', arguments);
              });
            }
          };
          xhr.send();
        }
      },
      localize: function() {
        console.error("localize() has not yet been defined by ready().");
      },
      stringsUpdated: function(L10n) {
        this.localize();        
      },
      ready: function () {
        this.sounds = {};
        this.eventListeners = [];
        if (this.ceci) return;
        this.addedCustomListeners = false;

        var that = this;

        //Use the app's audio context if it's ready
        var app = document.querySelector("ceci-app");
        if(app){ this.ctx = app.Audiocontext; }

        this.ceci = {
          broadcasts: {},
          listeners: {},
          editables: {},
          attributes: {}
        };

        this.ceciDefinition = processDefinition(this);

        if (!this.ceciDefinition) {
          console.error('Ceci definition required for ' + this.localName);
          return;
        }

        // bind the localised strings for attributes, unless there is already a stored attribute
        this.localize = (function() {

          this.ceciDefinition = processDefinition(this);
 
          var attributeResults = processAttributes(this.ceci.editables, this.ceciDefinition.attributes || {});

          Object.keys(attributeResults.attributeListeners).forEach(function (attributeName) {
            var listenerName = attributeResults.attributeListeners[attributeName];
            that[listenerName] = function (value) {
              that[attributeName] = value;
            };
          });

          Object.keys(this.ceciDefinition.listeners).forEach(function (listenerDefinitionName) {
            attributeResults.listeners[listenerDefinitionName] = that.ceciDefinition.listeners[listenerDefinitionName];
          });

          this._defaultListeners = processListeners(this.ceci.listeners, attributeResults.listeners);
          this._defaultBroadcasts = processBroadcasts(this.ceci.broadcasts, this.ceciDefinition.broadcasts);

          this.ceci.thumbnail = this.ceciDefinition.thumbnail;
          this.ceci.tags = this.ceciDefinition.tags || [];
          this.ceci.attributes = this.ceciDefinition.attributes || {};
          this.ceci.name = this.gettext(this.localName) || this.ceciDefinition.name || this.localName;

          Object.keys(this.ceciDefinition.attributes).forEach(function(key) {
            // we're using get/setAttribute because at this point that[key] is not guaranteed to work yet.
            if (!that.getAttribute(key)) {
              var lkey = that.localName + "/attributes/" + key;
              var lstring = that.getpropertytext(lkey);
              that.setAttribute(key, lstring);
            }
          });

          this.elementReady = true;
          this.fire('CeciElementReady', {});

        }).bind(this);

        this.L10n = loadL10n(this);
      },
      /**
       * Functions passed to onready will either run immediately, if the element is ready,
       * or once the element finishes its initialisation an CeciElementReady get fired off.
       */
      onready: function(fn) {
        if(this.elementReady) { fn(); }
        else {
          this.addEventListener('CeciElementReady', fn);
        }
      },
      applyDefaults: function () {
        // This code should never be moved to "attached" or be applied automatically when
        // the element is added to the page. It must be run explicitly by an external function,
        // since it's hard to detect whether or not this element is really "new" (e.g. someone
        // just added it to their app), or was created from a loaded app. In the latter case,
        // defaults should not be applied. Only when an element is new do we want this function
        // to run.

        var that = this;
        var map = document.querySelector("ceci-channel-map");
        var channel;
        var used = []; //Used channels so we don't use the same one for broadcasting and listening

        this._defaultListeners.forEach(function (d) {
          if (!that.querySelector('ceci-listen[for="' + d.name + '"]')) {
            channel = map.getFreeChannel("listener");
            that.setListener(d.name, channel);
            used.push(channel);
          }
        });

        this._defaultBroadcasts.forEach(function (d) {
          if (!that.querySelector('ceci-broadcast[from="' + d.name + '"]')) {
            channel = map.getFreeChannel("broadcast",used);
            that.setBroadcast(d.name, channel);
          }
        });
      },
      broadcast: function (name, data) {
        var broadcastElement = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcastElement) {
          var broadcastDetails = { channelName : broadcastElement.on, from : name};
          broadcastElement.fire(data);
        }
      },
      showContainingCard: function () {
        var potentialCard = this.parentNode;

        while (potentialCard && potentialCard.localName !== 'ceci-card') {
          potentialCard = potentialCard.parentNode;
        }

        if (potentialCard) {
          potentialCard.show();
        }
      },
      setListener: function (name, channel) {
        var entry = this.ceci.listeners[name];

        if (entry) {
          var listener = this.querySelector('ceci-listen[for="' + name + '"]');
          if (!listener) {
            listener = document.createElement('ceci-listen');
            this.appendChild(listener);
          }

          listener.setAttribute('on', channel);
          listener.setAttribute('for', name);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: channel, type: 'listen'}});
        }
        else {
          console.error('No listener definition found for "' + name + '".');
        }
      },
      setBroadcast: function (name, channel) {
        var entry = this.ceci.broadcasts[name];
        if (entry) {
          var broadcast = this.querySelector('ceci-broadcast[from="' + name + '"]');
          if (!broadcast) {
            broadcast = document.createElement('ceci-broadcast');
            this.appendChild(broadcast);
          }
          broadcast.setAttribute('on', channel);
          broadcast.setAttribute('from', name);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: channel, type: 'broadcast'}});
        }
        else {
          console.error('No broadcast definition found for "' + name + '".');
        }
      },
      removeListener: function (name) {
        var listen = this.querySelector('ceci-listen[for="' + name + '"]');
        if (listen) {
          this.removeChild(listen);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: null, type: 'listen'}});
        }
      },
      removeBroadcast: function (name) {
        var broadcast = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcast) {
          this.removeChild(broadcast);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: null, type: 'broadcast'}});
        }
      },
      attached: function () {
        if(!this.addedCustomListeners) {
          this.touchEnabled = 'ontouchstart' in document.documentElement;
          var els = this.shadowRoot.querySelectorAll(customListenerQuerySelector);
          Array.prototype.forEach.call(els, this.addCustomListener.bind(this));
          this.addedCustomListeners = true;
        }
        document.dispatchEvent(new CustomEvent('CeciElementAdded', {bubbles: true, detail: this}));
      },
      addCustomListener: function(el, listener){
        // Loop over the on-ceci-* listener types to see which one applies to this element
        var that = this;
        Object.keys(customListenerMap).forEach(function (listener) {
          if (!el.hasAttribute(listener)) return;

          // If there is a valid map entry, grab it
          var mapEntry = customListenerMap[listener];

          if(mapEntry) {
            // Fire an event directly at the element with the on-ceci-* attribute
            el.addEventListener(mapEntry[that.touchEnabled ? 'mobile' : 'desktop'], function(e){
              // Emit an event without the "on-" prefix, to let Polymer's template syntax sugar do the rest
              el.dispatchEvent(new CustomEvent(listener.substr(3), {bubbles: true, detail: this}));
            });
          }
        });
      },
      domReady: function () {
        document.dispatchEvent(new CustomEvent('CeciElementAdded', {bubbles: true, detail: this}));
      },
      /**
       * localise things based on their ontological path, like "ceci-element/attributes/description"
       * This should never give back the original string as acceptable localised string, and will
       * instead generate "" if there is no appropriate locale string found.
       */
      getpropertytext: function(keyname) {
        var localized = this.gettext(keyname);
        return (localized === keyname) ? "" : localized;
      },
      /**
       * localise things based on human text. Both input and output to this function should be human-
       * readable text, so that if no localised string exists, the original human-readable text is
       * simply sent back.
       */
      gettext: function (keyname) {
        return this.L10n.get(keyname);
      }
    });
  </script>
</polymer-element>
